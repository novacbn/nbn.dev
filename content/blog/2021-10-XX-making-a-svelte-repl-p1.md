# Making a Svelte REPL, Part 1

::: NOTE
To view the interactive samples in this blog post, Javascript is required.
:::

With the new [KahiPress CLI](https://github.com/kahi-framework/kahipress) complete, I figure it's time to make use of it to write some technical blog posts. So for the first post we're gonna step through making a REPL that's similar to the one that powers the [Kahi UI documentation](https://kahi-ui.nbn.dev).

## Goals

- **Lightweight**, should not require packages other than its self and the Svelte Compiler.
- **Configurable**, should be able to plug in your own globals / importing namespaces.
- **No Toolchain**, should not require a build toolchain like Rollup or have to make network request for a build server. e.g. [Svelte REPL](https://svelte.dev/repl)
- **Completely Internalized**, should not require embedding another webapp. e.g. Codepen or repl.it.

## Compiling a Component

> Documentation: https://svelte.dev/docs#svelte_compile

The most important technology we're gonna use is the built-in Svelte Compiler. Which is pretty flexible and treated as a first-class library API. However, we're only going to briefly cover it for what we need in this article.

So to start off how do we compile a Component? Well it's pretty easy if we look below:

:::WARNING
Keep an eye on your bundle size. The Svelte Compiler will seriously balloon it.
:::

```svelte {view=split}
<script>
    import {compile} from "svelte/compiler";

    // Below we're just scripting a basic Svelte view that allows
    // you to press a button to increment a number
    let input_source = \`<script>
    let count = 0;
</script>

{count}

<button on:click={() => (count++)}>+1</button>\`;

    // Then we take that Svelte source code and use the compiler
    // on it. By using a `$:` block, we can always get up to
    // date compiled code
    $: compiled_output = compile(input_source);
</script>

<!--
    Lastly, we're going to allow you to edit the initial source
    code via a `textarea` and then convert the output to JSON
    to display it
-->

<b>Source</b>

<textarea cols="35" rows="8" bind:value={input_source} />

<b>Compiled</b>

<textarea cols="35" rows="8" value={JSON.stringify(compiled_output, null, 4)} readonly />
```

With all the defaults, you should see something like this in the `compiled_output.js.code` field:

```javascript
/* generated by Svelte v3.40.2 */
import {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  space,
  text,
} from "svelte/internal";

function create_fragment(ctx) {
  let t0;
  let t1;
  let button;
  let mounted;
  let dispose;

  return {
    c() {
      t0 = text(/*count*/ ctx[0]);
      t1 = space();
      button = element("button");
      button.textContent = "+1";
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);

      if (!mounted) {
        dispose = listen(button, "click", /*click_handler*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t0, /*count*/ ctx[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(t0);
      if (detaching) detach(t1);
      if (detaching) detach(button);
      mounted = false;
      dispose();
    },
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;
  const click_handler = () => $$invalidate(0, count++, count);
  return [count, click_handler];
}

class Component extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default Component;
```

And you're done! You can even take that code now, and run it in a Svelte application without a compilation step. However there are a couple considerations for this:

1. It's using [ECMAScript Module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) (ESM) syntax, something we cannot polyfill virtual imports for.
2. It's also importing from `svelte/internal`. In our REPL we're not providing build tools, so how do we allow for virtual imports?

## ESM Syntax

Let's tackle first issue, the ESM syntax. This is also pretty easy for us to work with. The compiler provides a `compile(source, {format: "cjs"})` option which converts to [`CommonJS`](https://nodejs.org/docs/latest/api/modules.html) syntax instead:

```svelte {view=split}
<script>
    import {compile} from "svelte/compiler";

    let input_source = \`<script>
    let count = 0;
</script>

{count}

<button on:click={() => (count++)}>+1</button>\`;

    $: compiled_output = compile(input_source, {format: "cjs"});
</script>

<!--
    Lastly, we're going to allow you to edit the initial source
    code via a `textarea` and then convert the output to JSON
    to display it
-->

<b>Source</b>

<textarea cols="35" rows="8" bind:value={input_source} />

<b>Compiled</b>

<textarea cols="35" rows="8" value={JSON.stringify(compiled_output, null, 4)} readonly />
```

Again, you should see something like this in the `compiled_output.js.code` field:

```js
/* generated by Svelte v3.40.2 */
"use strict";

const {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  space,
  text,
} = require("svelte/internal");

function create_fragment(ctx) {
  let t0;
  let t1;
  let button;
  let mounted;
  let dispose;

  return {
    c() {
      t0 = text(/*count*/ ctx[0]);
      t1 = space();
      button = element("button");
      button.textContent = "+1";
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);

      if (!mounted) {
        dispose = listen(button, "click", /*click_handler*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t0, /*count*/ ctx[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(t0);
      if (detaching) detach(t1);
      if (detaching) detach(button);
      mounted = false;
      dispose();
    },
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;
  const click_handler = () => $$invalidate(0, count++, count);
  return [count, click_handler];
}

class Component extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

exports.default = Component;
```

Pretty neat right? Both `require` and `exports.default` are just native Javascript objects. Which we can polyfill globals for later.

## Evaluating our Code

Before we go onto the second consideration. We should first discuss how we're going to evaluate our code. Normally you might say one should just use [`eval`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval).

However it is extremely clunky to use for our purposes of wanting to provide globals. We would need to wrap the input in an enclosure, which could easily broken, similar to below:

```js
// Below we're defining the code that will be evaluated which exports a sample function
const input_source = `function add(a, b) {
    return a + b;
}

exports.add = add;`;

// Next we're wrapping the input in an enclosure that defines
// and returns an `exports` object to the evaluator
//
// We need to do an enclosure specifically, otherwise variables
// declarations in the `input_source` are global to the webpage
const exports = eval(`((exports = {}) => {
    ${input_source}

    return exports;
})();`);

console.log(exports.add(1, 3)); // `4`
```

A lot of string formatting right? Would be extremely easy for someone to break the evaluation. Not only that, how are we suppose to pass non-data globals in? And not just out? That's where the the newer [`new Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function) constructor comes in. Which allows us to define everything outside of the evaluation and pass-by-reference:

```js
// We can just use the same code as before
const input_source = `function add(a, b) {
    return a + b;
}

exports.add = add;`;

// This time, we're just going to define the `exports` object
// in this scope. Makes things simple!
const exports = {};

// Again we need an enclosure to encapsulate the variable
// declarations. But now we just need to pass in the global names
// and call the evaluation with the globals in corresponding order
new Function(
  "exports",
  `return (() => {
    ${input_source}
})();`
)(exports);

console.log(exports.add(1, 3)); // `4`
```

## CommonJS Polyfills

Great! We learned how to evaluate code with globals. But now we need polyfill the actual functionality CommonJS modules mostly expect:

- [`module`](https://nodejs.org/docs/latest/api/modules.html#modules_the_module_object) — Global that contains metadata about the module being evaluated.

  - Since we're only going to be evaluating from the Svelte Compiler output, we can mostly ignore this global.

- [`module.exports`](https://nodejs.org/docs/latest/api/modules.html#modules_module_exports) / [`exports`](https://nodejs.org/docs/latest/api/modules.html#modules_exports) — Contains the JS exports of the module being evaluated.

  - `exports` is just a global alias to `module.exports` for less typing.

- [`require`](https://nodejs.org/docs/latest/api/modules.html#modules_require_id) — Global function that takes a module identifier, and imports the module, then returns the exports.

  - Again, like `module`, our evaluated code is only gonna use `require` for importing modules. Nothing else like `require.resolve` needs polyfilling.

Not a terrible amount of things to polyfill really. And we already did a portion of the work in the last section. So let's take the previous implementation and add `module` support:

```js
const input_source = `function add(a, b) {
    return a + b;
}

exports.add = add;`;

// By wrapping the `module` / `module.exports` creation within a
// function, we can guarantee a new unique object for each module
function make_module() {
  // This time we just need to assign `exports` to `module.exports`
  return { exports: {} };
}

const module = make_module();

// Then we can just name the global and pass it on in
new Function(
  "module",
  "exports",
  `return (() => {
    ${input_source}
})();`
)(module, module.exports);

console.log(module.exports.add(1, 3)); // `4`
```

Simple change again. Let's add some `require` support. But first let's discuss what we're supporting.

Normally `require` on NodeJS looks up and evaluates a `.js` file relative to the currently executing file. An `index.js` file with a parent directory with a matching identifier. Or a package installed into the `node_modules` directory.

Running in a Browser... we have no filesystem to speak of. And while we can make a virtual one using a storage layer in the web, that's out of the scope of this post. So instead! We're going to just import the modules we want and create a static object of them:

:::WARNING
Keep an eye on your bundle size as you import modules.
:::

```js
import * as module_a from "module-a";
import * as module_b from "mobule-b";
import * as module_c from "module-c";

const IMPORTS = {
  "module-a": module_a,
  "module-b": module_b,
  "module-c": module_c,
};
```

Good, but uh, how do we use this object? We just need to make a function that takes our imports map object and returns a `require(identifier: string): any` function. Which matches the identifiers in the object and returns the associated exports:

```js
import * as module_a from "module-a";
import * as module_b from "mobule-b";
import * as module_c from "module-c";

const IMPORTS = {
  "module-a": module_a,
  "module-b": module_b,
  "module-c": module_c,
};

// By making a function that returns an anonymous function,
// we can just generate new `require` functions as needed
// for different contexts
function make_require(imports) {
  return (identifier) => {
    // First we need to check if the identifier is in the map,
    // and return the exports if found
    if (identifier in imports) return imports[identifier];

    // If not found, we need to throw an exception
    throw new Error(
      `bad argument #0 to 'require' (module '${identifier}' not found)`
    );
  };
}

const require = make_require(IMPORTS);

// Looks just like a normal `require` function huh?
const exports = require("module-a");
console.log(exports.add(1, 3)); // `4`
```

Now that we got that working, let's pull it in with our evaluation code.

```js
import * as module_a from "module-a";
import * as module_b from "mobule-b";
import * as module_c from "module-c";

const IMPORTS = {
  "module-a": module_a,
  "module-b": module_b,
  "module-c": module_c,
};

// We can add the require call into our input
const input_source = `const module_a = require("module-a");

function add(a, b) {
    return module_a.add(a, b);
}

exports.add = add;`;

function make_module() {
  return { exports: {} };
}

function make_require(imports) {
  return (identifier) => {
    if (identifier in imports) return imports[identifier];

    throw new Error(
      `bad argument #0 to 'require' (module '${identifier}' not found)`
    );
  };
}

const module = make_module();
const require = make_require(IMPORTS);

// And, just as before, pass in the new global
new Function(
  "module",
  "exports",
  "require",
  `return (() => {
    ${input_source}
})();`
)(module, module.exports, require);

console.log(module.exports.add(1, 3)); // `4`
```

We can then further streamline the whole shebang by encapsulating it in a function:

```js
import * as module_a from "module-a";
import * as module_b from "mobule-b";
import * as module_c from "module-c";

const IMPORTS = {
  "module-a": module_a,
  "module-b": module_b,
  "module-c": module_c,
};

const input_source = `const module_a = require("module-a");

function add(a, b) {
    return module_a.add(a, b);
}

exports.add = add;`;

function make_module() {
  return { exports: {} };
}

function make_require(imports) {
  return (identifier) => {
    if (identifier in imports) return imports[identifier];

    throw new Error(
      `bad argument #0 to 'require' (module '${identifier}' not found)`
    );
  };
}

// With this new function, we just pass in the imports map
// and get back a function that evaluates code with them
function make_evaluator(imports) {
  const require = make_require(imports);

  return (script) => {
    const module = make_module();

    new Function(
      "module",
      "exports",
      "require",
      `return (() => {
    ${script}
})();`
    )(module, module.exports, require);

    return module;
  };
}

const evaluator = make_evaluator(IMPORTS);
const module = evaluator(script);

console.log(module.exports.add(1, 3)); // `4`
```

## Compile :heart: Evaluation

... TODO

## Rendering the Evaluation

... TODO

## Final Words

Pretty easy right? With using the tools available to us from both Browsers and Svelte, we can forego a lot of complicated tooling.

Hope this post was useful to you in jump starting your next REPL-oriented project. In the next part there's more work to do like supporting CSS!
